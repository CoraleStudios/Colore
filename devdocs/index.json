{
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE.",
    "keywords": "This is the HOMEPAGE . Refer to Markdown for how to write markdown files. Quick Start Notes: Add images to the images folder if the file is referencing an image."
  },
  "README.html": {
    "href": "README.html",
    "title": "",
    "keywords": "Master : Develop : A powerful and elegant C# library for Razer Chroma's SDK Getting started If you are a new developer and are looking for a helpful guide on how to get started, head on over to the wiki page which describes getting Colore installed and running some example code. Contributing For discussing, you can join the Gitter chat using the badge above. If you want to join the Slack chat, contact Adam Hellberg ( sharparam@sharparam.com ). Contributors are very welcome! If you got code fixes, please submit a pull request here on GitHub. If you want to join the development team, please contact Sharparam on GitHub. All authors and contributors are listed in the AUTHORS file. Please read the CONTRIBUTING.md file before making a pull request. License Copyright Â© 2015-2017 by Adam Hellberg and Brandon Scott . This project is licensed under the MIT license, please see the file LICENSE for more information. Razer is a trademark and/or a registered trademark of Razer USA Ltd. All other trademarks are property of their respective owners. Installing Using Colore in your project is simple, all you have to do is install it with NuGet! Install-Package Colore Or using the .NET CLI tools: dotnet add package Colore You can also search for it in Visual Studio by right clicking your project and choosing \"Manage NuGet Packages...\" and install it the GUI way. Extensions The WPF and WinForms extension packages for Colore are not yet available for the new Colore version, but will be on NuGet soon, so stay tuned! Using Obtain a reference to an IChroma instance by calling Corale.Colore.ColoreProvider.CreateNative() . This instance initializes the Chroma SDK so it is important you save this reference for the lifetime of your application! If you need to dispose of it and obtain a new one later, be sure to call the uninitialize method first! Currently there is only support for binding to the native Chroma SDK . Support for the REST API is planned and will be implemented for the 6.0 release. For a more in-depth guide on how to get started, check out our wiki . Dependencies Colore depends on the Razer Chroma SDK ( RzChromaSDK64.dll or RzChromaSDK.dll ). The Razer Chroma SDK is provided by Razer and installed together with the Synapse application . More information can be read on their website . Other dependencies are installed via NuGet and listed in each project file. Building Colore supports building for multiple target frameworks. At the moment, these are .NET Standard 1.3 and .NET Framework 4.5.1. When building the project, DLLs for both frameworks will be generated in the output folders, under the folder names netstandard1.3 and net451 . Use the ones fitting for your application. The below examples compiles Colore in Release mode. .\\build.ps1 -Configuration Release You can also use the \"CI\" build target to generate the same artifacts made available for each release of Colore. .\\build.ps1 -Configuration Release -Target CI You will find the resulting artifact files under the artifacts folder in the root of the repository. Note that the above commands are executed with PowerShell . If you are building on a Linux system or macOS, use the build.sh script in place of build.ps1 (you may have to make it executable first with chmod +x build.sh ). Razer Chroma Workshop Many of the games and apps featured on the Razer Chroma Workshop have used the Colore library. The official Razer Chroma Workshop is your one-stop-shop to get the most out of your Chroma devices. Whether it's smart lighting based on in-game events, standalone apps or stunning profiles created by fans around the world, the Chroma Workshop is where you can explore, download and even share your own creations. Games using Colore The following games (powered by Unity) are using Colore: Projects using Colore Aurora - Unified lighting effects across multiple brands and various games. ( GitHub ) There may be others we are unaware of, so please let us know if there are any others."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "PLACEHOLDER",
    "keywords": "PLACEHOLDER TODO: Add .NET projects to the src folder and run docfx to generate REAL API Documentation !"
  },
  "articles/getting-started.html": {
    "href": "articles/getting-started.html",
    "title": "Getting Started",
    "keywords": "Getting Started 1. How to install Colore The easiest way to include Colore into your project is to right click on your C# Project in the Visual Studio Solution Explorer and Choose \"Manage NuGet Packages...\" From there you can search online for Packages. The NuGet Package manager sadly looks way different depending on the Version of Visual Studio but it should be easy to find Colore. Just search for \"Colore\" and install it. After that you should see a Reference being added to \"Colore\". Pre-release versions If you want to test the absolute latest features in Colore, which may not be fully ready for production use yet, you can install pre-release Colore packages from our MyGet feed . You can either install a version manually with the commands listed on the page, or add the feed to your NuGet settings: https://www.myget.org/F/coralestudios/api/v3/index.json . Make sure to select the MyGet feed when you are browsing packages in the package manager (or select \"All\" to see packages from all feeds at once), and to check the \"Include pre-releases\" checkbox. The MyGet feed will also include stable versions of Colore when they are released, so you can use it as the sole source for Colore. 2. How to make every Device the same Color Now in your Form you can just add a button for example and with a double-click it will take you to the form's source code and already created an event handler for that button when it is clicked. At the top of that file you should now include a using Colore; otherwise you need to prefix everything with Colore . I myself like to also add the following to the using statements to make sure I have the correct \"Color\". Otherwise it might interfere with System.Drawing : using ColoreColor = Colore.Data.Color; Now you change the Event Method like the following: private async void button1_Click(object sender, EventArgs e) { // Sets all Chroma devices to red, the 'chroma' variable should be saved // somewhere that is globally accessible to the application. var chroma = await ColoreProvider.CreateNativeAsync(); await chroma.SetAllAsync(ColoreColor.Red); // Without the usings it will look like this: // var chroma = await Colore.ColoreProvider.CreateNativeAsync(); // await chroma.SetAllAsync(Colore.Data.Color.Red); } If you then run your application and click the button you will see that all your chroma devices turned Red. A note on ColoreProvider Since version 6.0.0, Colore is designed to be asynchronous and less strict in how it is used. This means that the Chroma instance is now obtained differently. You can asynchronously instantiate either the native or REST API SDK in the following ways: // Create the regular native SDK backend, like in version 5.x ColoreProvider.CreateNativeAsync(); // When creating a Chroma instance using the REST API backend, you need to supply the SDK with information // about your app. var appInfo = new AppInfo(\"My app\", \"An awesome Chroma app!\", \"John Doe\", \"me@example.com\", Category.Application); ColoreProvider.CreateRestAsync(appInfo); There are also overloads taking a custom REST API endpoint which can be useful for testing, and an overload taking a bool parameter to control whether to use the SSL version of Razer's REST API. Each time you create a new Chroma instance in this way using ColoreProvider , the previously created instance will be uninitialized and discarded. For this reason, you should create your Chroma instance once at application startup and then use this instance for the remainder of your application's lifetime. For background applications that dynamically enable and disable Chroma features however, you can call the UninitializeAsync and InitializeAsync methods to control the lifetime. (Note that uninitializing the SDK manually this way doesn't always work properly with the SDK, and can sometimes leave it in a weird state.) 3. How to access Device Types Chroma SDK does not allow you to access one single device (as far as we know) but you can access Device Types. For example Keyboards, Mouse, Keypads... To do that with Colore here is an example for the Keyboard: Again this can be done without any using but we consider it easier and more readable. So add the following at the top of the file: using Colore.Effects.Keyboard; In some cases it might be helpful to also map it to another name as we did with the ColoreColor, but for now it's fine. Then change your method like this: private async void button1_Click(object sender, EventArgs e) { var chroma = await ColoreProvider.CreateNativeAsync(); await chroma.Keyboard.SetKeyAsync(Key.A, ColoreColor.Red); } (From now on, it will be assumed that the variable chroma contains an instance of IChroma created from ColoreProvider .) Now when you run it you will see that the \"A\" Key will glow Red. So it's pretty easy to use Colore :) To set a color on a Mouse for example: chroma.Mouse.SetLedAsync(Colore.Effects.Mouse.Led.Strip1, ColoreColor.Red); The following Devices are available as properties on the IChroma instance: Mousepad Keypad Headset Keyboard Mouse As a mousepad doesn't contain a SetKey method take a look at section 5. 4. How to define custom Colors You can of course define any color you like when you use new ColoreColor(1.0, 1.0, 1.0) . The numbers are in the order Red, Green and Blue where 1.0 is full color and 0.0 is nothing. Which makes this White (Red Green and Blue glowing at full bright). You can also use color values which range from 0 - 255 (the usual color range) but make sure to use or cast your value to byte to call the correct constructor. This can cause some trouble if you aren't careful: This will work as expected as it's using the byte constructor: new ColoreColor(255, 125, 125) This will NOT work as expected: new ColoreColor(255.0, 125.0, 125.0) This does work as expected: int i = 255; var color = new ColoreColor((byte)i, (byte)i, (byte)i); Result: Color with R=255, G=255, B=255 While this does NOT work as expected (the integers are coerced into floating point numbers): int i = 255; var color = new ColoreColor(i, i, i); Result: Color with R=1, G=1, B=1 5. How do I know which color is currently set on a Key / What if I don't want to set a Key but a specific row/column? Internally Colore is storing colors in a Grid. This Grid is then send to the Device. Instead of using SetKey you can directly edit that Grid which will also cause an update to the device by doing the following: chroma.Keyboard[Key.A] = ColoreColor.Red; This is the equivalent to SetKey above. But you can also read the value from this Grid with this method. For example: private void button1_Click(object sender, EventArgs e) { // Check if A currently is Red if (chroma.Keyboard[Key.A] == ColoreColor.Red) { // If it is, then set it to Blue chroma.Keyboard[Key.A] = ColoreColor.Blue; } else { // Otherwise set it to Red chroma.Keyboard[Key.A] = ColoreColor.Red; } } In some cases you can even access a virtual Grid instead of for example Key.A you can set the Key in the second row from the top and the fifth column from the left to Red: Chroma.Instance.Keyboard[1, 4] = ColoreColor.Red; The first int is row and the second is column. Starting with 0! There even are Constants that allow you to loop through all Keys: private async void button1_Click(object sender, EventArgs e) { var chroma = await ColoreProvider.CreateNativeAsync(); // Create a Random Generator Random random = new Random(); // Loop through all Rows for (uint r = 0; r < KeyboardConstants.MaxRows; r++) { //Loop through all Columns for (uint c = 0; c < KeyboardConstants.MaxColumns; c++) { // Set the current row and column to the random color chroma.Keyboard[r, c] = new ColoreColor(random.Next(256), random.Next(256), random.Next(256)); } } } The same thing can be archived with SetPosition : chroma.Keyboard.SetPositionAsync(1, 4, ColoreColor.Red); It depends on the device if it's available or not. 6. What about performance? Now it gets a bit more advanced and some people might think it's not actually needed as the SDK is very fast. But I personally love to manage my grids myself. The following example works for every device and if you do an application which does many updates at once I'd recommend it as you can at first set everything before sending it to the Keyboard, Mouse, Mousepad... . As said in point 5 Colore does internally also store a Grid, but everytime you change a Key via SetKey or the index (Keyboard[Key.A]) it sends an update to the Keyboard. That means if you set multiple Keys at once (maybe even update the whole Keyboard) it does many many many requests to the SDK. Better way in my opinion is to set everything in the grid and then update it. That's what the following code does. Now the code in your method: private async void button1_Click(object sender, EventArgs e) { var chroma = await ColoreProvider.CreateNativeAsync(); // Create the custom Grid var customGrid = MousepadCustom.Create(); // Set LED 0 (top right) and LED 14 (top left) to red customGrid[0] = ColoreColor.Red; customGrid[14] = ColoreColor.Red; // Apply the Grid to the Keyboard await chroma.Mousepad.SetCustomAsync(customGrid); } private async void button1_Click(object sender, EventArgs e) { var chroma = await ColoreProvider.CreateNativeAsync(); // Create the custom Grid var customGrid = MousepadCustom.Create(); // Set LED 0 (top right) and LED 14 (top left) to red customGrid[0] = ColoreColor.Red; customGrid[14] = ColoreColor.Red; // Apply the Grid to the Keyboard await chroma.Mousepad.SetCustomAsync(customGrid); // Create a custom for the Keyboard var keyboardGrid = KeyboardCustom.Create(); // Set the whole Grid to Green keyboardGrid.Set(ColoreColor.Green); // Set the A Key to Red keyboardGrid[Key.A] = ColoreColor.Red; // Set the Key in the second row and the fifth column to Red keyboardGrid[1,4] = ColoreColor.Red; // Apply the grid to the Keyboard await chroma.Keyboard.SetCustomAsync(keyboardGrid); } So the random Colors from before will look like the following making instead of many requests to the SDK just one per button click: // Create a Random Generator Random random = new Random(); // Create the custom Grid var keyboardGrid = KeyboardCustom.Create(); // Loop through all Rows for (var r = 0; r < Constants.MaxRows; r++) { //Loop through all Columns for (var c = 0; c < Constants.MaxColumns; c++) { // Set the current row and column to the random color keyboardGrid[r, c] = new ColoreColor(random.Next(256), random.Next(256), random.Next(256)); } } await chroma.Keyboard.SetCustomAsync(keyboardGrid); Credits Big thanks to WolfspiritM who initially created this guide!"
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Add your introductions here!",
    "keywords": "Add your introductions here!"
  },
  "CONTRIBUTING.html": {
    "href": "CONTRIBUTING.html",
    "title": "Contributing",
    "keywords": "Contributing We deeply appreciate anyone wanting to contribute to Colore! In order to make the code neat, readable, and organized properly, there are some guidelines and rules you must follow. Always remember, if you are unsure about something: check the existing source to get an idea of how things should look! If you have more specific questions about the guidelines or other things about the project, feel free to contact anyone listed under PRIMARY AUTHORS in the AUTHORS file or create an issue in the main repo . You can also join the Gitter chat and ask your questions. Cloning the repo First off, fork the repository and clone it to your local development system: git clone git@github.com:<your-username>/Colore.git General design guidelines Design your code to be event-driven when possible, it makes it easier for applications to implement the library. Follow common C# practices for cleaner looking code (properties instead of Get<Name> methods, for example). Development environment 2017-11-05: With Colore now being written using C# 7.0 and .NET Core features, you will need to use an edition of Visual Studio 2017 to develop on Colore. Installing the latest .NET Core SDK can also help as VS2017 currently does not download the latest version in its installer. Code analyzers Updated 2015-12-22: Colore is now on C# 6.0 which meant a move from the old StyleCop package to the new StyleCop.Analyzers package which implements StyleCop rules as Roslyn analyzers. Colore references the StyleCop.Analyzers and various other code analyzer packages, which will analyze the code and point out any errors. A global ruleset file Corale.Colore.ruleset provided with Colore defines the rules we use for Colore and will be used by analyzing tools automatically. If there are any conflicts between this guide and what analyzers tell you, generally follow what the analyzer says . This guide may not always be up to date with the latest changes to what rules we are using. If you feel unsure, feel free to create an issue or contact the primary developers or post a question in the Gitter chat room. Some analyzers can be very strict, or in some cases wrong about pieces of code. If you feel like there's a warning that should be suppressed for a section of code or even globally, feel free to do so but always mention this and your reasoning for doing so in your PR . We will discuss the suppression further in the PR. ReSharper ReSharper is used by the primary developers of Colore and as such, we provide a setting file with Colore that configures ReSharper with the settings we recommend using (such as naming conventions). If you use ReSharper, make sure that the team-shared settings are being used. Mandatory file header The following file header must be present in every code file , if it is missing your code will not be accepted until the header has been put in place. Invalid or missing file headers are detected by the StyleCop analyzers and can be remedied by utilizing the provided quick fix from within the editor. // --------------------------------------------------------------------------------------- // <copyright file=\"{NAME OF FILE WITH EXTENSION}\" company=\"Corale\"> // Copyright Â© 2015-2017 by Adam Hellberg and Brandon Scott. // // Permission is hereby granted, free of charge, to any person obtaining a copy of // this software and associated documentation files (the \"Software\"), to deal in // the Software without restriction, including without limitation the rights to // use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies // of the Software, and to permit persons to whom the Software is furnished to do // so, subject to the following conditions: // // The above copyright notice and this permission notice shall be included in all // copies or substantial portions of the Software. // // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN // CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. // // \"Razer\" is a trademark of Razer USA Ltd. // </copyright> // --------------------------------------------------------------------------------------- Indenting Use 4 spaces for indenting ( not tabs! ). No more, no less. Every decent IDE (and even text editor) lets you change this. Code with incorrect indentation will not be accepted until corrected. Using declarations StyleCop will notify you about incorrect using statements. Put using statements as deep as possible (usually it will be just after the namespace declaration) and in alphabetical order. System.* namespaces are always put at the top in their own alphabetical order. Example showing correctly sorted using statements using System; using Colore.Core; using SomeAuthor.SomeLib; (Space between using groups is optional, but can often make it easier to read.) Naming StyleCop will tell you how to name things most of the time. The only thing worth mentioning is that private fields are named by prefixing them with an underscore. The only exception is for const and static readonly in which case they are named using PascalCase. // Naming example for a private variable private SomeType _myVar; // Naming example for a private static readonly private static readonly SomeType MyVar; If you are using ReSharper, it will manage this for you, as we are using its default naming scheme. Exceptions to naming convention You should always try to name everything in a C#-idiomatic way, but we may make exceptions for exceptional cases, like when importing native code fragments. Exception throwing and handling Try not to catch the base Exception class, always catch specific exceptions that you are certain your code can handle. When throwing exceptions, throw a type that is relevant to the error that occurred, don't throw a base Exception if an argument is null , throw the ArgumentNullException . If creating custom exception types, append Exception to the name and inherit from the relevant base ColoreException class or one of the other exception classes in Colore, as per usual C# guidelines. Try to keep exception names short but descriptive. Usage of the var keyword With fancy IDEs and other tools, the need to explicitly specify the type of a variable is not as important. If you look through the source, you'll find that the var keyword is used extensively. However, whether or not you use the var keyword doesn't matter too much. If you find a piece of code more readable with the full type name, then write the full type name. Use your own judgement to decide whether using the var keyword makes your code more readable. That said, there are situations where using the var keyword is strongly encouraged, when the type name is mentioned in the statement (typically on assignment operations): // Consider this line of code: SpecialSuperType[] myArray = new SpecialSupertype[10]; // here it would be preferred to use the var keyword, as the type is already mentioned in the assignment var myArray = new SpecialSuperType[10]; Calling native Chroma SDK functions Never call native SDK functions directly . Always call SDK functions via the IChromaApi interface that is provided to all device classes as well as the main Chroma class. When implementing a new SDK function, add a fitting method in the IChromaApi interface and then implement the method in each SDK implementation wrapper (native and REST API). Remember to design the method on IChromaApi to be friendly in a C# context. The implementation will take care of making the calls to the underlying SDK, not the user of the API interface. Documenting your code Public-facing components of your code must have documentation. We will not merge pull requests that are missing documentation on public members. Use standard C# XML documentation comments for documenting your code, like so: /// <summary> /// Opens a webpage. /// </summary> /// <param name=\"url\">The URL to open.</param> /// <returns><c>true</c> if the webpage opened, <c>false</c> otherwise.</returns> public bool OpenWebpage(string url) { // Code... } If you are using Visual Studio, it will automatically insert the proper tags for you when you type three slashes where applicable ( /// ). Please use proper grammar and punctuation in your documentation comments for the convenience of the reader. We understand that not everyone is a native English speaker or have perfect language skills, and so we are pretty relaxed with the proper-ness of documentation comments. Simply: Badly written documentation comments are still better than no documentation comments at all. The important thing is that you can write something understandable. We will tell you in the pull request if there's something you can improve before we merge it. If you're referencing/importing/wrapping functions from external sources like the WinAPI or Razer's APIs you can simply copy documentation from the original source (MSDN for example). This usually means you get properly written documentation that is easy (ok, most of the time anyway) to understand. Submitting a pull request Good, we didn't scare you off with all these requirements, and you are on your way to submitting your first pull request! When making a pull request, if is often convenient to make a branch just for that request (so that you can continue working on your main development branch while your pull request is being reviewed). These branches are typically named patch-<counter> but can be anything you desire, like a descriptive name for what the PR is about. If you decide to name branches based on the change, make sure you keep them quite short. Another very positive thing for both you and us, the maintainers, is to avoid pull requests with a lot of commits that don't share anything in common. Imagine if you submit a pull request that implements a car and a pineapple. We decide that we like your car implementation, but that we're not quite ready for fruits yet. But we cannot choose, as you put them both in the same pull request! So always make sure that your pull request is handling one type of feature or change . Other things to keep in mind is to include details about what your feature or change is about in the pull request message. The more information the better! And make sure to give your pull request a relevant name, too. When you submit a pull request, there will be a handy template for you to read through so you don't forget any of the important parts! Pull request target branch When submitting your pull request, make sure you are targeting the develop branch of the main repo. If you target the wrong branch we will close your pull request. Don't feel bad though, just re-create it with the correct target branch! (We have to close it as GitHub does not support changing the target branch on an existing pull request.) Hotfixes Hotfixes are special, and are treated differently than other branches. A hotfix is branched from master and merged back into master and then to develop. If you ever write a hotfix, keep this in mind. Hotfixes branch from master, not develop ."
  },
  "CODE_OF_CONDUCT.html": {
    "href": "CODE_OF_CONDUCT.html",
    "title": "Contributor Covenant Code of Conduct",
    "keywords": "Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at colore@sharparam.com . The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4"
  }
}